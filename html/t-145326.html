<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="APE Structure Change" />

  <title>APE Structure Change - AVS Forums</title><!-- Bootstrap core CSS -->
  <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootswatch/3.0.2/readable/bootstrap.min.css" /><!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
                <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
                <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
</head>

<body>
  <div class="container">
    <div class="row">
        <div class="dropdown pull-right">
          <button class="btn btn-link btn-sm dropdown-toggle" type="button" data-toggle="dropdown">
            Change style
            <span class="caret"></span>
          </button>
          <ul id="css-select" class="dropdown-menu" role="menu">
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js">Default</a></li>
            <li role="presentation" class="divider"></li>
            <li role="presentation" class="dropdown-header">Bootswatch</li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/amelia/bootstrap.min.css">Amelia</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/cerulean/bootstrap.min.css">Cerulean</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/cosmo/bootstrap.min.css">Cosmo</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/cyborg/bootstrap.min.css">Cyborg</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/flatly/bootstrap.min.css">Flatly</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/journal/bootstrap.min.css">Journal</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/readable/bootstrap.min.css">Readable</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/simplex/bootstrap.min.css">Simplex</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/slate/bootstrap.min.css">Slate</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/spacelab/bootstrap.min.css">Spacelab</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/united/bootstrap.min.css">United</a></li>
            <li><a href="#" rel="//netdna.bootstrapcdn.com/bootswatch/3.0.2/yeti/bootstrap.min.css">Yeti</a></li>
          </ul>
        </div>
    </div>

    <ol class="breadcrumb">
      <li><a href="../index.html" class="glyphicon glyphicon-home"></a></li>

      <li><a href="f-139.html">AVS Troubleshooting</a></li>

      <li class="active">APE Structure Change</li>
    </ol>

    <p class="lead text-muted">Archive: <a title="Try the Internet Archive" target="_blank" href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=145326">APE Structure Change</a></p><br />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">shreyas_potnis</span><br /></p>

      <p class="post-time small text-muted">10th August 2003 15:09 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content"><strong>APE Structure Change</strong><br />
      These God damned cyber cafes...something went wrong and everything I typed was blown off.<br />
      Anyways, here goes:<br />
      Changing the entire sturcture of the APE to make them fast. The render function in AVS is passed the following values:<br />
      w,h,visdata,*framebuffer.<br />
      w=width, h=height, visdata(an array)=spectrum and all those values<br />
      *framebuffer= pointer to first pixel of AVS screen.<br />
      We need to modify all the variables from the one framebuffer points and w*h variables procedding them. The colour of the pixels is stored as intefer in the format 00 RR GG BB. So now we have to split the colour and then modify it and then again remake it. Instead what I propose is: Instead of passing a pointer to the colour, use 3 different integers for the colour of a pixel and pass 3 different points *r,*g,*b.<br />
      I know this would mean increasing the memory required by 3 times, but spliting each and every pixel and then creating it back is avoided.<br />
      <br />
      eg: (channel shift)<br />
      <br />
      .... Render (..,..,..,int *r, int *g, int *b)<br />
      {<br />
      int temp, wh;<br />
      for(int i=0; i&lt;h; i++)<br />
      for(j=0;j&lt;w;j++)<br />
      {<br />
      wh=i*j;<br />
      temp=*(r+wh);<br />
      *(r+wh)=*(g+wh);<br />
      *(g+wh)=temp;<br />
      }<br />
      <br />
      return 0;<br />
      }<br />
      <br />
      Simple isnt it?<br />
      <br />
      But making this possible is highly impossible I think.</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">UnConeD</span><br /></p>

      <p class="post-time small text-muted">10th August 2003 15:42 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content">Hah. You seriously need to learn how to do assembly/mmx coding. Here's the source code for the essential part of channel shift.<br />
      <br />
      It processes 4 pixels in a row (so it reduces the amount of code jumps by 4), but that's the only special thing about it.<br />
      <br /></p>
      <pre>
<code>        c = w*h;<br /><br />        switch (config.mode) {<br />        default:<br />        case IDC_RGB:<br />                return 0;<br />        case IDC_RBG:<br />                __asm {<br />                        mov ebx, framebuffer;<br />                        mov ecx, c;<br />                        lp1:<br />                        sub ecx, 4;<br /><br />                        mov eax, dword ptr [ebx+ecx*4];<br />                        xchg ah, al;<br />                        mov [ebx+ecx*4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+4];<br />                        xchg ah, al;<br />                        mov [ebx+ecx*4+4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+8];<br />                        xchg ah, al;<br />                        mov [ebx+ecx*4+8], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+12];<br />                        xchg ah, al;<br />                        mov [ebx+ecx*4+12], eax;<br /><br />                        test ecx, ecx;<br />                        jnz lp1;<br />                }<br />                break;<br />                <br />        case IDC_BRG:<br />                __asm {<br />                        mov ebx, framebuffer;<br />                        mov ecx, c;<br />                        lp2:<br />                        sub ecx, 4;<br />                        <br />                        mov eax, dword ptr [ebx+ecx*4];<br />                        mov dl, al;<br />                        shr eax, 8;<br />                        bswap eax;<br />                        mov ah, dl;<br />                        bswap eax;<br />                        mov [ebx+ecx*4], eax;<br />                        <br />                        mov eax, dword ptr [ebx+ecx*4+4];<br />                        mov dl, al;<br />                        shr eax, 8;<br />                        bswap eax;<br />                        mov ah, dl;<br />                        bswap eax;<br />                        mov [ebx+ecx*4+4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+8];<br />                        mov dl, al;<br />                        shr eax, 8;<br />                        bswap eax;<br />                        mov ah, dl;<br />                        bswap eax;<br />                        mov [ebx+ecx*4+8], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+12];<br />                        mov dl, al;<br />                        shr eax, 8;<br />                        bswap eax;<br />                        mov ah, dl;<br />                        bswap eax;<br />                        mov [ebx+ecx*4+12], eax;<br /><br />                        test ecx, ecx;<br />                        jnz lp2;<br />                }<br />                break;<br /><br />        case IDC_BGR:<br />                __asm {<br />                        mov ebx, framebuffer;<br />                        mov ecx, c;<br />                        lp3:<br />                        sub ecx, 4;<br /><br />                        mov eax, dword ptr [ebx+ecx*4];<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+4];<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4+4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+8];<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4+8], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+12];<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4+12], eax;<br /><br />                        test ecx, ecx;<br />                        jnz lp3;<br />                }<br />                break;<br /><br />        case IDC_GBR:<br />                __asm {<br />                        mov ebx, framebuffer;<br />                        mov ecx, c;<br />                        lp4:<br />                        sub ecx, 4;<br /><br />                        mov eax, dword ptr [ebx+ecx*4];<br />                        mov edx, eax;<br />                        bswap edx;<br />                        shl eax, 8;<br />                        mov al, dh;<br />                        mov [ebx+ecx*4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+4];<br />                        mov edx, eax;<br />                        bswap edx;<br />                        shl eax, 8;<br />                        mov al, dh;<br />                        mov [ebx+ecx*4+4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+8];<br />                        mov edx, eax;<br />                        bswap edx;<br />                        shl eax, 8;<br />                        mov al, dh;<br />                        mov [ebx+ecx*4+8], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+12];<br />                        mov edx, eax;<br />                        bswap edx;<br />                        shl eax, 8;<br />                        mov al, dh;<br />                        mov [ebx+ecx*4+12], eax;<br /><br />                        test ecx, ecx;<br />                        jnz lp4;<br />                }<br />                break;<br /><br />        case IDC_GRB:<br />                __asm {<br />                        mov ebx, framebuffer;<br />                        mov ecx, c;<br />                        lp5:<br />                        sub ecx, 4;<br /><br />                        mov eax, dword ptr [ebx+ecx*4];<br />                        shl eax, 8;<br />                        bswap eax;<br />                        xchg ah, al;<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+4];<br />                        shl eax, 8;<br />                        bswap eax;<br />                        xchg ah, al;<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4+4], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+8];<br />                        shl eax, 8;<br />                        bswap eax;<br />                        xchg ah, al;<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4+8], eax;<br /><br />                        mov eax, dword ptr [ebx+ecx*4+12];<br />                        shl eax, 8;<br />                        bswap eax;<br />                        xchg ah, al;<br />                        bswap eax;<br />                        shr eax, 8;<br />                        mov [ebx+ecx*4+12], eax;<br /><br />                        test ecx, ecx;<br />                        jnz lp5;<br />                }<br />                break;<br />        }<br />        return 0;<br /></code>
</pre><br />
      <br />
      <br />
      But what you're saying IS already possible. Just do this:<br />
      <br />
      <pre>
<code><br />unsigned char *r, *g, *b;<br /><br />b = g = r = (unsigned char *) framebuffer;<br />b+=2; ++g;<br /></code>
</pre><br />
      <br />
      And then skip 4 bytes ahead every time using <font face="courier new">r+=4;g+=4;b+=4</font>.<br />
      <br />
      But this is wildly inefficient because the x86 has a 32-bit wide memory bus and works much faster when processing entire, dword aligned, 32-bit blocks.<br />
      <br />
      The current memory structure IS the most efficient. You're just not using it correctly.<br />
      <br />
      The same goes for most other C/C++ tricks. You might think "a^=b;b^=a;a^=b;" is a smart way of exchanging vars, but in fact it's wildly inefficient unless you have a compiler that specifically recognizes that code.
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">[Ishan]</span><br /></p>

      <p class="post-time small text-muted">12th August 2003 16:02 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content">argh..tech stuff:confused:<br />
      i'm just happy to <b>use</b> ape's :p not create them:p<br />
      <br />
      <font size="1">yes, i'm a very cheap person;)</font></p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">jheriko</span><br /></p>

      <p class="post-time small text-muted">17th August 2003 07:12 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content">MMX is great for working with colors. You can perform quite a few equivalents to x86 instructions on all four colour components at once, SSE and SSE2 fill the gaps in MMX but they aren't so widespread.<br />
      I'd recommend looking it up.. it actually makes a lot of code easier. Like an RGB&lt;-&gt;BGR swap, commonly needed in reading bitmap files, for instance... not that I'd have ever have thought of doing 4 pixels at a time for code speed.<br />
      <br />
      /me notes UCDs idea down on list of things to steal<br />
      <br />
      How could a compiler not directly compile a bitwise XOR statement? What else would it need to do with it? Surely when a piece of C code with a^=b;b^=a;a^=b; is compiled that code is replaced in the assembly with xor a, b xor b, a xor a, b (insert registers and mov as required). P9s always telling me about how immensely efficient C compilers actually are and how you'd think it would be crap but it optimises code really well and junk.</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">UnConeD</span><br /></p>

      <p class="post-time small text-muted">18th August 2003 23:12 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content">In my experience at least the xor-switch thingy sucks.<br />
      <br />
      This is because the vars are not stored in registers, and the code becomes:<br />
      <br />
      load a -&gt; 1;<br />
      load b -&gt; 2;<br />
      xor 1,2 -&gt; 1;<br />
      store a &lt;- 1;<br />
      <br />
      load b -&gt; 1;<br />
      load a -&gt; 2;<br />
      xor 1,2 -&gt; 1;<br />
      store b &lt;- 1;<br />
      <br />
      load a -&gt; 1;<br />
      load b -&gt; 2;<br />
      xor 1,2 -&gt; 1;<br />
      store a &lt;- 1;<br />
      <br />
      With 1,2 being two CPU registers. This means 6 loads and 3 stores.<br />
      <br />
      Something like that.<br />
      <br />
      The better statement would simply be:<br />
      <br />
      register 'type' temp;<br />
      temp = a; a = b; b = temp;<br />
      <br />
      Which a proper compiler should indeed optimize into the following snippet (which I use through inline asm):<br />
      <br />
      __asm {<br />
      mov eax, var1;<br />
      mov ecx, var2;<br />
      mov var1, ecx;<br />
      mov var2, eax;<br />
      }<br />
      <br />
      2 loads and 2 stores...<br />
      It could be that caching simply removes the inefficiency, I really don't know much about modern CPU performance these days.<br />
      <br />
      I've only toyed around with MSVC++ though, I've heard Intel's C++ compiler is much better at optimizing.<br />
      The thing is, C/C++ allows you to express certain stuff in really compact code, but the translation to machine code can turn out to be much more complicated on an x86.<br />
      <br />
      I don't know if the 4-pixels-at-a-time actually has any effect on a modern cpu, but a jump used to kill the instruction cache last time I checked. I should really benchmark this stuff ;)... in any case, it probably can't hurt, and because AVS always has multiples of 4 pixels, you don't need extra checking for it to work.</p>
    </div>
    <hr />

    <div class="footer">
      <p class="text-muted small">Fork me on <a href="https://github.com/visbot/AVS-Forums/">GitHub</a></p>
    </div>
  </div><!-- Put JavaScript here -->
  <script type="text/javascript" src="//code.jquery.com/jquery-1.10.2.min.js"></script>
<script type="text/javascript" src="//netdna.bootstrapcdn.com/bootstrap/3.0.2/js/bootstrap.min.js"></script>
  <script type="text/javascript" src="../js/jquery.cookie.min.js"></script>
  <script type="text/javascript" src="../js/scripts.js"></script>
</body>
</html>
