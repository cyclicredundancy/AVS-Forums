<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="description" content="Custom BPM"><title>Custom BPM - AVS Forums</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-53539506-7','auto');ga('send','pageview');</script><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/readable/bootstrap.min.css" as="style" onload="this.rel='stylesheet'"> <noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/readable/bootstrap.min.css"></noscript> <script>!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);</script></head><body style="display:none"><div class="container"><div class="row"><div class="dropdown pull-right"><button class="btn btn-link btn-sm dropdown-toggle" type="button" data-toggle="dropdown">Change style <span class="caret"></span></button><ul id="css-select" class="dropdown-menu" role="menu"><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">Default</a></li><li role="presentation" class="divider"></li><li role="presentation" class="dropdown-header">Bootswatch</li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/amelia/bootstrap.min.css">Amelia</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/cerulean/bootstrap.min.css">Cerulean</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/cosmo/bootstrap.min.css">Cosmo</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/cyborg/bootstrap.min.css">Cyborg</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/flatly/bootstrap.min.css">Flatly</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/journal/bootstrap.min.css">Journal</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/readable/bootstrap.min.css">Readable</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/simplex/bootstrap.min.css">Simplex</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/slate/bootstrap.min.css">Slate</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/spacelab/bootstrap.min.css">Spacelab</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/united/bootstrap.min.css">United</a></li><li><a href="#" rel="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.3.7/yeti/bootstrap.min.css">Yeti</a></li></ul></div></div><ol class="breadcrumb"><li><a href="../index.html" class="glyphicon glyphicon-home"></a></li><li><a href="f-139.html">AVS Troubleshooting</a></li><li class="active">Custom BPM</li></ol><p class="lead text-muted">Archive: <a title="Try the Internet Archive" target="_blank" href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=253109">Custom BPM</a></p><br><div class="post"><p class="post-meta"><span class="post-author text-primary">Yathosho</span><br></p><p class="post-time small text-muted">12th August 2006 10:02 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content"><strong>Custom BPM</strong><br>hello, i'm new to this avs thing. can anybody please explain what "reverse" in custom bpm does? :D</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">ASD5A</span><br></p><p class="post-time small text-muted">12th August 2006 10:34 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">"reverse" switches the indication of beat.<br>ie. if a beat is detected custom bpm will output that there is no beat.<br>and if there is no beat custom bpm will output that there is a beat.<br><br>i hope you understand my crappy explanation.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Tuggummi</span><br></p><p class="post-time small text-muted">12th August 2006 10:37 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">In other words<br><br>Regular:<br>sound-sound-sound-sound-!BEAT!-sound-sound-sound<br><br>Reverse:<br>!BEAT!-!BEAT!-!BEAT!-!BEAT!-sound-!BEAT!-!BEAT!-!BEAT!<br><br><br><br>A explanation even a 3 year old or me could understand.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Warrior of the Light</span><br></p><p class="post-time small text-muted">6th September 2006 16:35 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">Another n00b question; I didn't have the balls to create a new thead :o<br><br>&gt; What does 'Page Flipping' in the Fullscreen options do?<br><br>I'm writing a Quick Start Guide for AVS and I'd like to explain it</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">jheriko</span><br></p><p class="post-time small text-muted">6th September 2006 16:46 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">Page flipping is probably double buffering.<br><br>In theory (and in practice) double buffering works like turning a page then turning it back, that it and it claims to make things "smoother but a little slower" which also fits double buffering.<br><br>Double buffering is where the renderer draws to an invisible buffer and then renders that to the screen when its finished. This stops the 'tearing' artefact.<br><br>I'll test it when I get home... which is soon cos its the end of my work day. Yay!</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">jheriko</span><br></p><p class="post-time small text-muted">6th September 2006 17:18 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">Sorry, now that I am home and have checked... what I describe above is labelled "Wait for retrace"<br><br>EDIT: Page flipping is the same, but instead of copying the whole buffer, once the trace is complete, it swaps the pointers to the buffers. since these are 32-bit addresses you can swap the buffers in the time it takes to copy a single pixel, instead of the whole screen of them.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Warrior of the Light</span><br></p><p class="post-time small text-muted">6th September 2006 19:04 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">Let's see if I got it straight (in general terms).<br><br><i>Raw projection</i>:<br>AVS renders to buffer1. buffer1 is projected to the screen.<br><br><i>Wait for retrace</i>:<br>AVS renders to buffer2.<br>If buffer2 is full, buffer1 = buffer2. buffer1 is projected to the screen.<br><br><i>Page flipping</i><br><font size="1">(using buffer[0] and buffer[1], a is a boolean)</font><br>AVS renders to buffer[a]. buffer[not a] is projected to the screen.<br><font color="silver"><font size="1">(I know that a isn't an integer but you get the point)</font></font><br>If the render buffer is full, a=not a<br><br>--<br><br>Is that it? If so, it makes me wonder why the normal wait for retrace option is still used.<br>Also makes me wonder about the 'slower..' warning. PF should, by this definition, be faster than 'wait for retrace'.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">jheriko</span><br></p><p class="post-time small text-muted">7th September 2006 15:24 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">I'm not sure why page flipping is slower and smoother it might mean something other than the standard meaning for avs.<br><br>Manipulating a single pointer is invariably faster than manipulating a large 2D array. However if the pointer is in software memory then the buffer would still need copying to the graphics card... I will experiment some more when I get home today.<br><br>Its possible that page flipping and wait for retrace interact with each other, or that one has precedence over the other. In this case the 'slower and smoother' might be referring to a regular render, since page flipping waits for a retrace it will reduce the framerate (slower) for the benefit of removing the 'cuts' (smoother). I'll have to see if page flipping forces wait for retrace or not.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">PAK-9</span><br></p><p class="post-time small text-muted">9th September 2006 19:56 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">There is no reason why wait for retrace and page flipping would 'interact' with each other.. and a precidence would imply they are mutually exclusive which they are not.<br><br>I do agree though, its a bit confusing as to why it is labelled as 'slower' when in actuality it should be faster.</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">Warrior of the Light</span><br></p><p class="post-time small text-muted">10th September 2006 22:51 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">I'm also puzzled about why it's only in the Fullscreen options and not in Display..<br><br>It could be that it simply was not added yet, or there might be a reason why it's not possible for that mode - if it is what we think it is to begin with.<br><br>I've been through the soucefile, but I didn't have much luck with finding it so far.<br>But then, I'm just a C++ newb<br><br>--<br>@Yathosho: sorry for hijacking your thread; I had guessed that everbody but me knew it..</p></div><hr><div class="post"><p class="post-meta"><span class="post-author text-primary">StevenRoy</span><br></p><p class="post-time small text-muted">20th September 2006 22:37 <abbr title="Coordinated Universal Time">UTC</abbr></p><p class="post-content">This is probably more accurate:<br><br>"Direct":<br>AVS copies each frame directly to the screen (more accurately, the "front buffer" in video memory) as soon as it's rendered. (Since the frame is assembled in memory before being copied to the screen, this is actually a form of software double-buffering.)<br><br>Wait for retrace:<br>AVS waits for the next vertical retrace, so it can copy each frame directly to video memory while nothing is actually being drawn on the screen. Results: No "tearing" (unless your computer's slow), smoother animation, and the animation can't go faster than the refresh rate of the monitor (which is as it should be, in my view).<br><br>Page flipping:<br>AVS copies each frame to a "back buffer" in video memory as soon as it's rendered, then instructs the video hardware to swap that buffer for the active front buffer. Depending on the video card, this may happen immediately (with possible tearing) or, more likely, during a retrace. If the video card waits for the retrace, though, AVS is still free to work on the next frame during this time. Thus, it may still be limited to the refresh rate of the monitor (as it should be), but it should be smoother and slightly faster overall than with just "Wait for retrace".<br><br>This hardware double-buffering, by the way, can't be used on the desktop, because it'd flip the entire desktop. It only works with full-screen modes, and possibly overlays. That's why it can't be applied to AVS in a window (unless it's running in overlay mode, but I don't think that support is complete).<br><br>All of this is assuming, of course, that this part of AVS is programmed the way that I would've done it. I've got the source downloaded, so I might have to take a look at it to confirm that this is right. (Pity I don't program in C++, otherwise I might even try to revive the project. There's so much code there that I could probably optimise...)</p></div><hr><div class="footer"><p class="text-muted small">Fork me on <a href="https://github.com/visbot/AVS-Forums/">GitHub</a></p></div></div><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" defer></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" defer></script><script type="text/javascript" src="../js/jquery.cookie.min.js" defer></script><script type="text/javascript" src="../js/scripts.js" defer></script></body></html>