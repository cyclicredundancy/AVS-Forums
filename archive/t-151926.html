<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="Texer Suggestions" />

  <title>Texer Suggestions - AVS Forums</title><!-- Bootstrap core CSS -->
  <link rel="stylesheet" type="text/css" href="//netdna.bootstrapcdn.com/bootswatch/3.0.1/readable/bootstrap.min.css" /><!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!--[if lt IE 9]>
                <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
                <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
</head>

<body>
  <div class="container">
    <!-- Put navigation bar here -->

    <ol class="breadcrumb">
      <li><a href="../index.html" class="glyphicon glyphicon-home"></a></li>

      <li><a href="f-138.html">AVS Wishlist</a></li>

      <li class="active">Texer Suggestions</li>
    </ol>

    <p class="lead text-muted">Archive: <a title="Try the Internet Archive" target="_blank" href="http://web.archive.org/web/*/forums.winamp.com/showthread.php?t=151926">Texer Suggestions</a></p><br />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Zevensoft</span><br /></p>

      <p class="post-time small text-muted">8th October 2003 06:51 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content"><strong>Texer Suggestions</strong><br />
      I have a few ideas for Texer which could make it 1/0 times better.<br />
      <br />
      <b>Faster renderer</b><br />
      1. Scan the image for pixels, and store them in an array with each non-black pixel's x,y,r,g,b values.<br />
      2. Go through per-pixel and check if any bitmaps from points in the array intersect with the pixel, and add their respective r,g,b bitmap values together and output at the current pixel.<br />
      <br />
      It's a trade off, basically it enables much larger bitmaps to be drawn without a trade off in speed, but more of them makes it slower.<br />
      [Possible toggle option perhaps?]<br />
      <br />
      Example (Psuedocode):<br /></p>
      <pre>
<code><br />sub main<br />    ScanImage<br />    RenderImage<br />end sub<br /><br />function ScanImage<br />    for y = 0 to avswin.height<br />    for x = 0 to avswin.width<br /><br />        if PixelColour is not black then<br />            add PixelPos,PixelColour to array<br />        end if<br /><br />    next x<br />    next y<br />end function<br /><br />function RenderImage<br />    for y = 0 to avswin.height<br />    for x = 0 to avswin.width<br />    set FinalPixelColour to black<br />    for n = 0 to NumberInArray    <br /><br />        if (abs(x-pixelx(n)) &lt;= bitmap.width) and (abs(y-pixely(n)) &lt; bitmap.height) then<br />            add PixelColour(n) to FinalPixelColour<br />        end if<br />    next n<br />    plot FinalPixelColour at (x,y)<br />    next x<br />    next y<br />end function<br /></code>
</pre><br />
      <br />
      <b>New "Texer Modes"</b><br />
      With this new rendering method, several new "texer modes" are possible. Here are some of my ideas:<br />
      <br />
      1. RGB -&gt; XYB scaling<br />
      <br />
      This is basically where BLUE maps to the brightness, and the RED and GREEN components of a points colour are mapped to a scalar of X and Y axis respectively. It should probably be mapped to an inverse of w and h respectively. This is equivalent to a formula of xscale=w/(red*2-1) and yscale=h/(green*2-1). This would also make the texer non pixel scale dependant. It's also fairly simple to implement, just change the functions for finding whether the pixel is intersecting the point in the bitmap, and the function for getting the colour from that pixel for the point in the bitmap.<br />
      <br />
      2. RGB -&gt; TZB Rotation/Scaling<br />
      <br />
      Similar to the above, but with RED mapping to THETA and GREEN mapping to a Z scalar. The Z scalar is calculated the same as the x/y scalars in the above example. The THETA value is calculated as simply theta=red*pi*2.<br />
      <br />
      3. I'm sure there are other things someone could think of.<br />
      <br />
      Hopefully you'll consider my ideas UnConeD.
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Zevensoft</span><br /></p>

      <p class="post-time small text-muted">8th October 2003 08:21 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content">Another mode idea:<br />
      <br />
      <b>Switched Image</b><br />
      Have a list of bitmaps with associated colours, so that when a pixel is a certain colour, a certain full colour bitmap is rendered.</p>
    </div>
    <hr />

    <div class="post">
      <p class="post-meta"><span class="post-author text-primary">Deamon</span><br /></p>

      <p class="post-time small text-muted">8th October 2003 10:00 <abbr title="Coordinated Universal Time">UTC</abbr></p>

      <p class="post-content">I don't understand much about your first post ;) But hell, I love you second idea :). and hell, the first one must be great as well. It sounds smart.</p>
    </div>
    <hr />

    <div class="footer">
      <p class="text-muted small">Fork me on <a href="https://github.com/visbot/AVS-Forums/">GitHub</a></p>
    </div>
  </div><!-- Put JavaScript here -->
</body>
</html>
